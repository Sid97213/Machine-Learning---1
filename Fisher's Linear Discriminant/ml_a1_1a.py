# -*- coding: utf-8 -*-
"""ML_A1_1A

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ltP5-Syqd8Pddzd893KfWzRHbMG2L1DQ
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm
from matplotlib.pyplot import figure
import plotly.express as px
import plotly.graph_objects as go

from google.colab import files
files.upload()

data = np.loadtxt('dataset_FLD.csv', dtype='float', delimiter=',')
data_labels = data[:,3].reshape(data.shape[0],)
data_features = data[:,:3]

df = pd.DataFrame({
    'Feature1':data_features[:,0],
    'Feature2':data_features[:,1],
    'Feature3':data_features[:,2],
    'label':data_labels
})
fig = px.scatter_3d(df, x = 'Feature1', y= 'Feature2', z = 'Feature3', color='label')
fig.update_layout(scene = dict(
    xaxis_title='Feature1',
    yaxis_title='Feature2',
    zaxis_title='Feature3'),
    width=700,
    margin=dict(r=20, b=10, l=10, t=10))
fig.show()

for i in range(len(data)):
    data[i][3] = int(data[i][3])

m1x, m1y, m1z = 0, 0, 0
m2x, m2y, m2z = 0, 0, 0
cnt1, cnt2 = 0, 0

for i in range(len(data)):
    if (data[i][3] == 0):
        m1x += data[i][0]
        m1y += data[i][1]
        m1z += data[i][2]
        cnt1 += 1
    else:
        m2x += data[i][0]
        m2y += data[i][1]
        m2z += data[i][2]
        cnt2 += 1

print(cnt1, cnt2)

m1x /= cnt1
m1y /= cnt1
m1z /= cnt1
m2x /= cnt2
m2y /= cnt2
m2z /= cnt2

m1 = [m1x,m1y,m1z]
m2 = [m2x,m2y,m2z]
m1 = np.array(m1)
m2 = np.array(m2)
m1 = m1[:, np.newaxis]
m2 = m2[:, np.newaxis]
print(m1)
print(m2)

sw1 = np.zeros((3,3), dtype=np.float64)
sw2 = np.zeros((3,3), dtype=np.float64)

for i in range(len(data)):
    if(data[i][3]==0):
        diff=[]
        diff.append(data[i][0]-m1[0][0])
        diff.append(data[i][1]-m1[1][0])
        diff.append(data[i][2]-m1[2][0])
        diff=np.array(diff)
        diff=diff[:, np.newaxis]
        sw1+=diff.dot(diff.transpose())
    else:
        diff=[]
        diff.append(data[i][0]-m2[0][0])
        diff.append(data[i][1]-m2[1][0])
        diff.append(data[i][2]-m2[2][0])
        diff=np.array(diff)
        diff=diff[:, np.newaxis]
        sw2+=diff.dot(diff.transpose())
sw=(sw1/cnt1)+(sw2/cnt2)
print("Sw: ",sw)

print("The value of M1 is:")
print(m1)
print("The value of M2 is:")
print(m2)

w=np.linalg.inv(sw).dot((m2-m1))
p = np.linalg.norm(w)
print("The weight vector is:")
print(w)
print("Mod of vector is:   ", p)
unit_w = 1*(w/p)
print("The unit weight vector is:   ")

w = unit_w
print(w)

Mu1=w.transpose().dot(m1)[0][0]
Mu2=w.transpose().dot(m2)[0][0]

print("The value of m1 is:")
print(Mu1)
print("The value of m2 is:")
print(Mu2)

c1, c2 = [],[]
for i in range(len(data)):
    if(data[i][3]==0):
        xn=[]
        xn.append(data[i][0])
        xn.append(data[i][1])
        xn.append(data[i][2])
        xn=np.array(xn)
        xn=xn[:,np.newaxis]
        c1.append(w.transpose().dot(xn)[0][0])
    else:
        xn=[]
        xn.append(data[i][0])
        xn.append(data[i][1])
        xn.append(data[i][2])
        xn=np.array(xn)
        xn=xn[:,np.newaxis]
        c2.append(w.transpose().dot(xn)[0][0])
c1=sorted(c1)
c2=sorted(c2)

std1=np.std(c1)
std2=np.std(c2)
print("Std Dev Class 1: ",std1)
print("Std Dev Class 2: ",std2)

p1=norm.pdf(c1,Mu1,std1)
p2=norm.pdf(c2,Mu2,std2)
plt.plot(c1,p1)
plt.plot(c2,p2)

a = 1/(2*std1**2) - 1/(2*std2**2)
b = Mu2/(std2**2) - Mu1/(std1**2)
c = Mu1**2 /(2*std1**2) - Mu2**2 / (2*std2**2) - np.log(std2/std1)
print("a = ", a)
print("b = ", b)
print("c = ", c)

sol = np.roots([a,b,c])
print(sol)

if(abs(Mu1 - sol[0]) + abs(Mu2 - sol[0]) == abs(Mu1 - Mu2)):
    threshold = sol[0]
else:
    threshold=sol[1]
print("Threshold:   ", threshold)

a = min(Mu1 - 3*std1, Mu1 + 3*std1)
b = max(Mu2 - 3*std2, Mu2 + 3*std2)
# X_axis1 = np.linspace(Mu1 - 3*std1, Mu1 + 3*std1, 10000)
# X_axis2 = np.linspace(Mu2 - 3*std2, Mu2 + 3*std2, 10000)
X_axis = np.linspace(a,b,10000)

plt.plot(X_axis, norm.pdf(X_axis, Mu1, std1),'-', color='b',label='Class 1 (value 1)')    
plt.plot(X_axis, norm.pdf(X_axis, Mu2, std2),'-', color='r',label='Class 2 (value 0)')
plt.axvline(threshold, label="Discriminant:  " + str(threshold), c = "black")
plt.legend(loc = 'upper right')
plt.title('Normal distributions. Threshold = '+ str(threshold))
plt.plot([threshold], norm.pdf([threshold], Mu1, std1), '.', color='g',label='Threshold')
plt.show()

tp,tn,fp,fn = 0, 0, 0, 0
for i in range(len(data)):
    if(data[i][3]==0):
        xn=[]
        xn.append(data[i][0])
        xn.append(data[i][1])
        xn.append(data[i][2])
        xn=np.array(xn)
        xn=xn[:,np.newaxis]
        if w.transpose().dot(xn)[0][0]<threshold:
            tn+=1
        else:
            fn+=1
    else:
        xn=[]
        xn.append(data[i][0])
        xn.append(data[i][1])
        xn.append(data[i][2])
        xn=np.array(xn)
        xn=xn[:,np.newaxis]
        if w.transpose().dot(xn)[0][0]>threshold:
            tp+=1 
        else:
            fp+=1
print("Accuracy: ",float(tp+tn)/len(data)*100,"%")

precision=float(tp)/(tp+fp)
recall=float(tp)/(tp+fn)
print("F Score: ",2*precision*recall/(precision+recall))

print("The threshold is:")
print(threshold)
print("The accuracy is:")
print(float(tp+tn)/len(data)*100,"%")
print("The F-score is:")
print(2*precision*recall/(precision+recall))

y=np.linspace(0,0,num=500)
plt.scatter(c1,y)
plt.scatter(c2,y)
plt.scatter(threshold,0,c='k')
plt.axvline(threshold, label="Discriminant" + str(threshold), c = "black")
plt.title('1D Projections. Threshold = '+ str(threshold))
plt.legend(loc = 'upper right')
plt.show()

df = pd.DataFrame({'Comp0':data_features[:,0],
                   'Comp1':data_features[:,1],
                   'Comp2':data_features[:,2],
                   'label':data_labels})

fig = px.scatter_3d(df, x='Comp0', y='Comp1', z='Comp2',color = 'label')
# fig.show()
# create x,y
xx, yy = np.meshgrid(range(10), range(10))

# calculate corresponding z
z = (-w[0] * xx - w[1] * yy - threshold) * 1. /w[2]

# plot the surface

fig = plt.figure().gca(projection='3d')
fig.plot_surface(xx, yy, z, alpha=0.3)

fig = plt.figure(figsize=(7,5))
ax = fig.add_subplot(projection = '3d')
ax.set_title('3D Projections')
ax.set_xlabel('Feature 1')
ax.set_ylabel('Feature 2')
ax.set_zlabel('Feature 3')

df_dataframe = df.sort_values(by='label')
df_dataframe.reset_index(drop=True, inplace=True)
c=0
for i in np.array(df_dataframe.iloc[:,-1]):
    c+=1
    if i==1:
        break
df_dataframe_neg = df_dataframe.iloc[0:c-1]
df_dataframe_posi = df_dataframe.iloc[c-1:]

x1 = [i for i in np.array(df_dataframe_posi.iloc[:,0])]
x2 = [i for i in np.array(df_dataframe_posi.iloc[:,1])]
x3 = [i for i in np.array(df_dataframe_posi.iloc[:,2])]
ax.scatter(x1,x2,x3, color = "yellow", label = "Positive", marker = "+")

x1 = [i for i in np.array(df_dataframe_neg.iloc[:,0])]
x2 = [i for i in np.array(df_dataframe_neg.iloc[:,1])]
x3 = [i for i in np.array(df_dataframe_neg.iloc[:,2])]
ax.scatter(x1,x2,x3, color = "blue", label = "Negative", marker = "_")


x1 = np.linspace(-10,10,100)
x2 = np.linspace(-10,10,100)
X1,X2 = np.meshgrid(x1,x2)
X3 = (threshold - (w[0]*X1 + w[1]*X2))/(w[2])
ax.plot_surface(X1,X2,X3,alpha=0.3)
plt.legend()
plt.show()

df = pd.DataFrame({'Comp0':data_features[:,0],
                   'Comp1':data_features[:,1],
                   'Comp2':data_features[:,2],
                   'label':data_labels})

# create x,y
x1 = np.linspace(-10,10,100)
x2 = np.linspace(-10,10,100)
X1,X2 = np.meshgrid(x1,x2)

# calculate corresponding z
z = (threshold - (w[0] * X1 + w[1] * X2)) * 1. /w[2]

# plot the surface and the points
fig = go.Figure(data = [go.Surface(x=x1,y=x2,z=z)])
fig.add_scatter3d(x=df['Comp0'], y=df['Comp1'], z=df['Comp2'],
                   mode='markers', marker={'color':df['label'], 'size': 4})
fig.update_layout(scene = dict(
                    xaxis_title='Feature1',
                    yaxis_title='Feature2',
                    zaxis_title='Feature3'),
                    width=700,
                    margin=dict(r=20, b=10, l=10, t=10))

fig.show()

